// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
)

const createPeer = `-- name: CreatePeer :exec
INSERT INTO peers (email, peer_id, interface_id, allowed_ip, config)
VALUES ($1, $2, $3, $4, $5)
`

type CreatePeerParams struct {
	Email       string
	PeerID      string
	InterfaceID string
	AllowedIp   string
	Config      string
}

func (q *Queries) CreatePeer(ctx context.Context, arg CreatePeerParams) error {
	_, err := q.db.ExecContext(ctx, createPeer,
		arg.Email,
		arg.PeerID,
		arg.InterfaceID,
		arg.AllowedIp,
		arg.Config,
	)
	return err
}

const updatePeerConfig = `-- name: UpdatePeerConfig :exec
UPDATE peers
SET config = $1
WHERE peer_id = $2
`

type UpdatePeerConfigParams struct {
	Config string
	PeerID string
}

func (q *Queries) UpdatePeerConfig(ctx context.Context, arg UpdatePeerConfigParams) error {
	_, err := q.db.ExecContext(ctx, updatePeerConfig,
		arg.Config,
		arg.PeerID,
	)
	return err
}

const deletePeerByID = `-- name: DeletePeerByID :exec
DELETE FROM peers
WHERE peer_id = $1
`

func (q *Queries) DeletePeerByID(ctx context.Context, peerID string) error {
	_, err := q.db.ExecContext(ctx, deletePeerByID, peerID)
	return err
}

const getPeerByEmail = `-- name: GetPeerByEmail :one
SELECT email, peer_id, interface_id, allowed_ip, config, created_at
FROM peers
WHERE email = $1
LIMIT 1
`

func (q *Queries) GetPeerByEmail(ctx context.Context, email string) (Peer, error) {
	row := q.db.QueryRowContext(ctx, getPeerByEmail, email)
	var i Peer
	err := row.Scan(
		&i.Email,
		&i.PeerID,
		&i.InterfaceID,
		&i.AllowedIp,
		&i.Config,
		&i.CreatedAt,
	)
	return i, err
}

const getPeerByID = `-- name: GetPeerByID :one
SELECT email, peer_id, interface_id, allowed_ip, config, created_at
FROM peers
WHERE peer_id = $1
LIMIT 1
`

func (q *Queries) GetPeerByID(ctx context.Context, peerID string) (Peer, error) {
	row := q.db.QueryRowContext(ctx, getPeerByID, peerID)
	var i Peer
	err := row.Scan(
		&i.Email,
		&i.PeerID,
		&i.InterfaceID,
		&i.AllowedIp,
		&i.Config,
		&i.CreatedAt,
	)
	return i, err
}

const getPeerByEmailAndInterface = `-- name: GetPeerByEmailAndInterface :one
SELECT email, peer_id, interface_id, allowed_ip, config, created_at
FROM peers
WHERE email = $1 AND interface_id = $2
LIMIT 1
`

type GetPeerByEmailAndInterfaceParams struct {
	Email       string
	InterfaceID string
}

func (q *Queries) GetPeerByEmailAndInterface(ctx context.Context, arg GetPeerByEmailAndInterfaceParams) (Peer, error) {
	row := q.db.QueryRowContext(ctx, getPeerByEmailAndInterface, arg.Email, arg.InterfaceID)
	var i Peer
	err := row.Scan(
		&i.Email,
		&i.PeerID,
		&i.InterfaceID,
		&i.AllowedIp,
		&i.Config,
		&i.CreatedAt,
	)
	return i, err
}

const deletePeersByInterface = `-- name: DeletePeersByInterface :exec
DELETE FROM peers
WHERE interface_id = $1
`

func (q *Queries) DeletePeersByInterface(ctx context.Context, interfaceID string) error {
	_, err := q.db.ExecContext(ctx, deletePeersByInterface, interfaceID)
	return err
}

const listPeers = `-- name: ListPeers :many
SELECT email, peer_id, interface_id, allowed_ip, config, created_at
FROM peers
ORDER BY created_at DESC
`

func (q *Queries) ListPeers(ctx context.Context) ([]Peer, error) {
	rows, err := q.db.QueryContext(ctx, listPeers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Peer
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.Email,
			&i.PeerID,
			&i.InterfaceID,
			&i.AllowedIp,
			&i.Config,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPeersByEmail = `-- name: ListPeersByEmail :many
SELECT email, peer_id, interface_id, allowed_ip, config, created_at
FROM peers
WHERE email = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPeersByEmail(ctx context.Context, email string) ([]Peer, error) {
	rows, err := q.db.QueryContext(ctx, listPeersByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Peer
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.Email,
			&i.PeerID,
			&i.InterfaceID,
			&i.AllowedIp,
			&i.Config,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPeersByInterface = `-- name: ListPeersByInterface :many
SELECT email, peer_id, interface_id, allowed_ip, config, created_at
FROM peers
WHERE interface_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPeersByInterface(ctx context.Context, interfaceID string) ([]Peer, error) {
	rows, err := q.db.QueryContext(ctx, listPeersByInterface, interfaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Peer
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.Email,
			&i.PeerID,
			&i.InterfaceID,
			&i.AllowedIp,
			&i.Config,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createInterface = `-- name: CreateInterface :exec
INSERT INTO interfaces (id, name, address, listen_port, mtu, endpoint)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateInterfaceParams struct {
	ID         string
	Name       string
	Address    string
	ListenPort int64
	Mtu        int64
	Endpoint   string
}

func (q *Queries) CreateInterface(ctx context.Context, arg CreateInterfaceParams) error {
	_, err := q.db.ExecContext(ctx, createInterface,
		arg.ID,
		arg.Name,
		arg.Address,
		arg.ListenPort,
		arg.Mtu,
		arg.Endpoint,
	)
	return err
}

const updateInterface = `-- name: UpdateInterface :exec
UPDATE interfaces
SET name = $1, address = $2, listen_port = $3, mtu = $4, endpoint = $5
WHERE id = $6
`

type UpdateInterfaceParams struct {
	Name       string
	Address    string
	ListenPort int64
	Mtu        int64
	Endpoint   string
	ID         string
}

func (q *Queries) UpdateInterface(ctx context.Context, arg UpdateInterfaceParams) error {
	_, err := q.db.ExecContext(ctx, updateInterface,
		arg.Name,
		arg.Address,
		arg.ListenPort,
		arg.Mtu,
		arg.Endpoint,
		arg.ID,
	)
	return err
}

const deleteInterface = `-- name: DeleteInterface :exec
DELETE FROM interfaces
WHERE id = $1
`

func (q *Queries) DeleteInterface(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteInterface, id)
	return err
}

const getInterface = `-- name: GetInterface :one
SELECT id, name, address, listen_port, mtu, endpoint, created_at
FROM interfaces
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetInterface(ctx context.Context, id string) (Interface, error) {
	row := q.db.QueryRowContext(ctx, getInterface, id)
	var i Interface
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.ListenPort,
		&i.Mtu,
		&i.Endpoint,
		&i.CreatedAt,
	)
	return i, err
}

const listInterfaces = `-- name: ListInterfaces :many
SELECT id, name, address, listen_port, mtu, endpoint, created_at
FROM interfaces
ORDER BY id
`

func (q *Queries) ListInterfaces(ctx context.Context) ([]Interface, error) {
	rows, err := q.db.QueryContext(ctx, listInterfaces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Interface
	for rows.Next() {
		var i Interface
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.ListenPort,
			&i.Mtu,
			&i.Endpoint,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createAllowedEmail = `-- name: CreateAllowedEmail :exec
INSERT INTO allowed_emails (interface_id, email)
VALUES ($1, $2)
`

type CreateAllowedEmailParams struct {
	InterfaceID string
	Email       string
}

func (q *Queries) CreateAllowedEmail(ctx context.Context, arg CreateAllowedEmailParams) error {
	_, err := q.db.ExecContext(ctx, createAllowedEmail, arg.InterfaceID, arg.Email)
	return err
}

const deleteAllowedEmail = `-- name: DeleteAllowedEmail :exec
DELETE FROM allowed_emails
WHERE interface_id = $1 AND email = $2
`

type DeleteAllowedEmailParams struct {
	InterfaceID string
	Email       string
}

func (q *Queries) DeleteAllowedEmail(ctx context.Context, arg DeleteAllowedEmailParams) error {
	_, err := q.db.ExecContext(ctx, deleteAllowedEmail, arg.InterfaceID, arg.Email)
	return err
}

const deleteAllowedEmailsByInterface = `-- name: DeleteAllowedEmailsByInterface :exec
DELETE FROM allowed_emails
WHERE interface_id = $1
`

func (q *Queries) DeleteAllowedEmailsByInterface(ctx context.Context, interfaceID string) error {
	_, err := q.db.ExecContext(ctx, deleteAllowedEmailsByInterface, interfaceID)
	return err
}

const listAllowedEmails = `-- name: ListAllowedEmails :many
SELECT interface_id, email, created_at
FROM allowed_emails
WHERE interface_id = $1
ORDER BY email
`

func (q *Queries) ListAllowedEmails(ctx context.Context, interfaceID string) ([]AllowedEmail, error) {
	rows, err := q.db.QueryContext(ctx, listAllowedEmails, interfaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllowedEmail
	for rows.Next() {
		var i AllowedEmail
		if err := rows.Scan(
			&i.InterfaceID,
			&i.Email,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllowedInterfacesByEmail = `-- name: ListAllowedInterfacesByEmail :many
SELECT interface_id
FROM allowed_emails
WHERE email = $1
ORDER BY interface_id
`

func (q *Queries) ListAllowedInterfacesByEmail(ctx context.Context, email string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAllowedInterfacesByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var interfaceID string
		if err := rows.Scan(&interfaceID); err != nil {
			return nil, err
		}
		items = append(items, interfaceID)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allowedEmailExists = `-- name: AllowedEmailExists :one
SELECT COUNT(1)
FROM allowed_emails
WHERE interface_id = $1 AND email = $2
`

type AllowedEmailExistsParams struct {
	InterfaceID string
	Email       string
}

func (q *Queries) AllowedEmailExists(ctx context.Context, arg AllowedEmailExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, allowedEmailExists, arg.InterfaceID, arg.Email)
	var count int64
	err := row.Scan(&count)
	return count, err
}
